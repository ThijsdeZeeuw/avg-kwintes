#!/bin/bash
# Enhanced Configuration Script for Local AI Stack on Ubuntu 24.04
# Ensures proper port settings, networking, and external API access for all services

set -e # Exit on error

# Display banner
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë                                                            ‚ïë"
echo "‚ïë   Local AI Stack - VPS Configuration Tool for Ubuntu 24.04 ‚ïë"
echo "‚ïë                                                            ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

# Check if running as root
if [ "$(id -u)" -ne 0 ]; then
    echo "‚ùå This script must be run as root or with sudo"
    exit 1
fi

# Set working directory
if [ -d "/root/avg-kwintes" ]; then
    cd /root/avg-kwintes
elif [ -d "$(dirname "$0")" ]; then
    cd "$(dirname "$0")"
else
    echo "‚ùå Working directory not found. Run this script from the project directory."
    exit 1
fi

echo "üìÇ Working directory: $(pwd)"

# Define color codes
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# 1. Update .env file with correct configurations
echo -e "${BLUE}üîß Checking .env file...${NC}"
if [ -f ".env" ]; then
    # Load current values from .env
    source .env
    
    # Update n8n port to avoid conflict with Supabase
    sed -i 's/N8N_PORT=.*/N8N_PORT=5678/' ".env"
    
    # Ensure LETSENCRYPT_EMAIL is set
    if grep -q "LETSENCRYPT_EMAIL=" ".env"; then
        if [ -z "$LETSENCRYPT_EMAIL" ]; then
            echo -e "${YELLOW}! Setting default LETSENCRYPT_EMAIL${NC}"
            sed -i 's/LETSENCRYPT_EMAIL=.*/LETSENCRYPT_EMAIL=tddezeeuw@gmail.com/' ".env"
        fi
    else
        echo "LETSENCRYPT_EMAIL=tddezeeuw@gmail.com" >> ".env"
    fi
    
    # Set timezone if not already set
    if grep -q "TZ=" ".env"; then
        if [ -z "$TZ" ]; then
            echo -e "${YELLOW}! Setting default timezone${NC}"
            sed -i 's/TZ=.*/TZ=Europe\/Amsterdam/' ".env"
        fi
    else
        echo "TZ=Europe/Amsterdam" >> ".env"
    fi
    
    # Verify domain name is set
    if ! grep -q "DOMAIN_NAME=" ".env" || [ -z "$DOMAIN_NAME" ]; then
        read -p "Enter your domain name (e.g., example.com): " domain_name
        if [ -n "$domain_name" ]; then
            if grep -q "DOMAIN_NAME=" ".env"; then
                sed -i "s/DOMAIN_NAME=.*/DOMAIN_NAME=$domain_name/" ".env"
            else
                echo "DOMAIN_NAME=$domain_name" >> ".env"
            fi
            DOMAIN_NAME="$domain_name"
        else
            echo -e "${YELLOW}! Using default domain: kwintes.cloud${NC}"
            if grep -q "DOMAIN_NAME=" ".env"; then
                sed -i "s/DOMAIN_NAME=.*/DOMAIN_NAME=kwintes.cloud/" ".env"
            else
                echo "DOMAIN_NAME=kwintes.cloud" >> ".env"
            fi
            DOMAIN_NAME="kwintes.cloud"
        fi
    fi
    
    echo -e "${GREEN}‚úì Updated .env file with correct settings${NC}"
else
    # Create basic .env file if it doesn't exist
    echo -e "${YELLOW}! .env file not found. Creating basic configuration.${NC}"
    
    read -p "Enter your domain name (e.g., example.com): " domain_name
    if [ -z "$domain_name" ]; then
        domain_name="kwintes.cloud"
        echo -e "${YELLOW}! Using default domain: kwintes.cloud${NC}"
    fi
    
    cat > ".env" << EOF
# Basic configuration generated by fix_config.sh
DOMAIN_NAME=${domain_name}
SUBDOMAIN=n8n
LETSENCRYPT_EMAIL=tddezeeuw@gmail.com
TZ=Europe/Amsterdam
N8N_PORT=5678
N8N_HOSTNAME=n8n.${domain_name}
WEBUI_HOSTNAME=openwebui.${domain_name}
FLOWISE_HOSTNAME=flowise.${domain_name}
SUPABASE_HOSTNAME=supabase.${domain_name}
OLLAMA_HOSTNAME=ollama.${domain_name}
SEARXNG_HOSTNAME=searxng.${domain_name}
FLOWISE_USERNAME=admin
FLOWISE_PASSWORD=password
GRAFANA_ADMIN_USER=admin
GRAFANA_ADMIN_PASS=password
EOF
    
    echo -e "${GREEN}‚úì Created basic .env file${NC}"
    echo -e "${YELLOW}! Please update sensitive credentials in .env file before production use${NC}"
    
    # Load the newly created .env
    source .env
    DOMAIN_NAME="$domain_name"
fi

# Generate strong random tokens if needed
if ! grep -q "N8N_ENCRYPTION_KEY=" ".env" || ! grep -q "N8N_USER_MANAGEMENT_JWT_SECRET=" ".env"; then
    echo -e "${YELLOW}! Generating strong random tokens for n8n${NC}"
    
    n8n_encryption_key=$(tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 32)
    n8n_jwt_secret=$(tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 32)
    
    if grep -q "N8N_ENCRYPTION_KEY=" ".env"; then
        sed -i "s/N8N_ENCRYPTION_KEY=.*/N8N_ENCRYPTION_KEY=$n8n_encryption_key/" ".env"
    else
        echo "N8N_ENCRYPTION_KEY=$n8n_encryption_key" >> ".env"
    fi
    
    if grep -q "N8N_USER_MANAGEMENT_JWT_SECRET=" ".env"; then
        sed -i "s/N8N_USER_MANAGEMENT_JWT_SECRET=.*/N8N_USER_MANAGEMENT_JWT_SECRET=$n8n_jwt_secret/" ".env"
    else
        echo "N8N_USER_MANAGEMENT_JWT_SECRET=$n8n_jwt_secret" >> ".env"
    fi
fi

# 2. Update Caddyfile to use the correct configuration
echo -e "${BLUE}üîß Updating Caddyfile...${NC}"
cat > Caddyfile << 'EOL'
{
    # Global options
    email {$LETSENCRYPT_EMAIL}
    admin off
    auto_https disable_redirects # Modified to use a more stable option
    servers {
        protocol {
            experimental_http3
        }
    }
}

# Root domain redirect to n8n
{$DOMAIN_NAME} {
    redir https://n8n.{$DOMAIN_NAME} permanent
    tls {
        protocols tls1.2 tls1.3
    }
}

# N8N - Workflow Automation
{$N8N_HOSTNAME} {
    reverse_proxy n8n:5678
    tls {
        protocols tls1.2 tls1.3
    }
}

# Open WebUI - AI Interface
{$WEBUI_HOSTNAME} {
    reverse_proxy open-webui:8080
    tls {
        protocols tls1.2 tls1.3
    }
}

# Flowise - AI Flow Builder
{$FLOWISE_HOSTNAME} {
    reverse_proxy flowise:3001
    tls {
        protocols tls1.2 tls1.3
    }
}

# Ollama API - LLM Server
{$OLLAMA_HOSTNAME} {
    reverse_proxy ollama:11434
    tls {
        protocols tls1.2 tls1.3
    }
}

# Supabase - Backend Services
{$SUPABASE_HOSTNAME} {
    reverse_proxy supabase:3000
    tls {
        protocols tls1.2 tls1.3
    }
}

# Supabase Studio - Database Administration
studio.{$DOMAIN_NAME} {
    reverse_proxy kong:8000/
    tls {
        protocols tls1.2 tls1.3
    }
}

# SearXNG - Privacy Search Engine
{$SEARXNG_HOSTNAME} {
    encode zstd gzip
    
    @api {
        path /config
        path /healthz
        path /stats/errors
        path /stats/checker
    }
    @search {
        path /search
    }
    @imageproxy {
        path /image_proxy
    }
    @static {
        path /static/*
    }
    
    header {
        # CSP (https://content-security-policy.com)
        Content-Security-Policy "upgrade-insecure-requests; default-src 'none'; script-src 'self'; style-src 'self' 'unsafe-inline'; form-action 'self' https://github.com/searxng/searxng/issues/new; font-src 'self'; frame-ancestors 'self'; base-uri 'self'; connect-src 'self' https://overpass-api.de; img-src * data:; frame-src https://www.youtube-nocookie.com https://player.vimeo.com https://www.dailymotion.com https://www.deezer.com https://www.mixcloud.com https://w.soundcloud.com https://embed.spotify.com;"
        # Disable some browser features
        Permissions-Policy "accelerometer=(),camera=(),geolocation=(),gyroscope=(),magnetometer=(),microphone=(),payment=(),usb=()"
        # Set referrer policy
        Referrer-Policy "no-referrer"
        # Force clients to use HTTPS
        Strict-Transport-Security "max-age=31536000"
        # Prevent MIME type sniffing from the declared Content-Type
        X-Content-Type-Options "nosniff"
        # X-Robots-Tag (comment to allow site indexing)
        X-Robots-Tag "noindex, noarchive, nofollow"
        # Remove "Server" header
        -Server
    }
    
    header @api {
        Access-Control-Allow-Methods "GET, OPTIONS"
        Access-Control-Allow-Origin "*"
    }
    
    route {
        # Cache policy
        header Cache-Control "max-age=0, no-store"
        header @search Cache-Control "max-age=5, private"
        header @imageproxy Cache-Control "max-age=604800, public"
        header @static Cache-Control "max-age=31536000, public, immutable"
    }
    
    # SearXNG (uWSGI)
    reverse_proxy searxng:8080 {
        header_up X-Forwarded-Port {http.request.port}
        header_up X-Real-IP {http.request.remote.host}
        # https://github.com/searx/searx-docker/issues/24
        header_up Connection "close"
    }
    tls {
        protocols tls1.2 tls1.3
    }
}

# Grafana - Monitoring Dashboard
grafana.{$DOMAIN_NAME} {
    reverse_proxy grafana:3000
    tls {
        protocols tls1.2 tls1.3
    }
}

# Prometheus - Metrics Collection
prometheus.{$DOMAIN_NAME} {
    reverse_proxy prometheus:9090
    tls {
        protocols tls1.2 tls1.3
    }
}

# Qdrant API - Vector Database
qdrant.{$DOMAIN_NAME} {
    reverse_proxy qdrant:6333
    tls {
        protocols tls1.2 tls1.3
    }
}

# Whisper API - Speech to Text
whisper.{$DOMAIN_NAME} {
    reverse_proxy whisper:9000
    tls {
        protocols tls1.2 tls1.3
    }
}
EOL
echo -e "${GREEN}‚úì Updated Caddyfile with correct configuration${NC}"

# 3. Update docker-compose.yml with integrated changes
echo -e "${BLUE}üîß Updating docker-compose.yml...${NC}"

# Check if docker-compose.yml exists
if [ ! -f "docker-compose.yml" ]; then
    echo -e "${RED}‚ùå docker-compose.yml not found. This script requires an existing docker-compose.yml file.${NC}"
    exit 1
fi

# Make sure port mappings are correct and consistent
if grep -q "8008:8000" docker-compose.yml; then
    echo -e "${YELLOW}! Updating n8n port in docker-compose.yml...${NC}"
    sed -i 's/- 8008:8000/- 5678:5678/' docker-compose.yml
    echo -e "${GREEN}‚úì Updated n8n port mapping from 8008:8000 to 5678:5678${NC}"
fi

# Update OpenWebUI port to be consistent
if grep -q "\"3000:8080\"" docker-compose.yml; then
    echo -e "${YELLOW}! Updating OpenWebUI port in docker-compose.yml...${NC}"
    sed -i 's/- "3000:8080"/- "8080:8080"/' docker-compose.yml
    echo -e "${GREEN}‚úì Updated OpenWebUI port mapping from 3000:8080 to 8080:8080${NC}"
fi

# Update Grafana port to be consistent
if grep -q "3005:3000" docker-compose.yml; then
    echo -e "${YELLOW}! Updating Grafana port in docker-compose.yml...${NC}"
    sed -i 's/- 3005:3000/- 3000:3000/' docker-compose.yml
    echo -e "${GREEN}‚úì Updated Grafana port mapping from 3005:3000 to 3000:3000${NC}"
fi

# Add additional environment variables to n8n service for external API access
if ! grep -q "N8N_SECURE_COOKIE" docker-compose.yml; then
    echo -e "${YELLOW}! Adding external API environment variables to n8n service...${NC}"
    sed -i '/x-n8n: &service-n8n/,/x-ollama/s/- NODE_FUNCTION_ALLOW_EXTERNAL=\*/- NODE_FUNCTION_ALLOW_EXTERNAL=\*\n    - N8N_METRICS_ENABLED=true\n    - N8N_SECURE_COOKIE=false\n    - N8N_SKIP_WEBHOOK_DEREGISTRATION_SHUTDOWN=true\n    - WEBHOOK_URL=https:\/\/${SUBDOMAIN:-n8n}.${DOMAIN_NAME:-kwintes.cloud}\//' docker-compose.yml
    echo -e "${GREEN}‚úì Added n8n environment variables for external API access${NC}"
fi

# Ensure all services use the monitoring network
echo -e "${BLUE}üîß Ensuring all services use the monitoring network...${NC}"
services_updated=0
for service in n8n flowise open-webui grafana prometheus qdrant searxng redis ollama-cpu ollama-gpu ollama-gpu-amd whisper; do
    if grep -q "^  $service:" docker-compose.yml; then
        if ! grep -q "^  $service:" -A 20 docker-compose.yml | grep -q "networks:" || ! grep -q "^  $service:" -A 25 docker-compose.yml | grep -q "monitoring"; then
            echo -e "${YELLOW}! Adding monitoring network to $service${NC}"
            sed -i "/^  $service:/,/^  [a-z]/ s/^  [a-z]/    networks:\n      - monitoring\n\n  &/" docker-compose.yml
            services_updated=$((services_updated + 1))
        fi
    fi
done

if [ $services_updated -gt 0 ]; then
    echo -e "${GREEN}‚úì Added monitoring network to $services_updated services${NC}"
else
    echo -e "${GREEN}‚úì All services already configured with monitoring network${NC}"
fi

# 4. Update firewall settings
echo -e "${BLUE}üîß Checking firewall settings...${NC}"
if command -v ufw > /dev/null; then
    echo -e "${YELLOW}! Configuring UFW firewall...${NC}"
    ufw status | grep -q "Status: active" || ufw enable
    
    # Define ports to open
    declare -A ports=(
        ["SSH"]="22"
        ["HTTP"]="80"
        ["HTTPS"]="443"
        ["n8n"]="5678"
        ["Flowise"]="3001"
        ["OpenWebUI"]="8080"
        ["Grafana"]="3000"
        ["Supabase API"]="8000"
        ["Ollama"]="11434"
        ["Qdrant"]="6333"
        ["Prometheus"]="9090"
        ["Supabase Studio"]="54321"
    )
    
    # Check and open ports
    for service in "${!ports[@]}"; do
        port="${ports[$service]}"
        if ! ufw status | grep -q "$port/tcp"; then
            echo -e "${YELLOW}! Opening port $port for $service${NC}"
            ufw allow "$port/tcp"
        else
            echo -e "${GREEN}‚úì Port $port already open for $service${NC}"
        fi
    done
    
    echo -e "${GREEN}‚úì Firewall configured${NC}"
else
    echo -e "${YELLOW}! UFW not installed. Please configure your firewall manually.${NC}"
fi

# 5. Remove any existing docker-compose.override.yml file
if [ -f "docker-compose.override.yml" ]; then
    echo -e "${YELLOW}! Removing docker-compose.override.yml...${NC}"
    rm docker-compose.override.yml
    echo -e "${GREEN}‚úì Removed override file as changes are now integrated into main file${NC}"
fi

# 6. Check for Docker installation and proper versions
echo -e "${BLUE}üîß Checking Docker installation...${NC}"
if ! command -v docker >/dev/null 2>&1; then
    echo -e "${RED}‚ùå Docker is not installed. Installing Docker...${NC}"
    apt-get update
    apt-get install -y docker.io
    systemctl enable docker
    systemctl start docker
    echo -e "${GREEN}‚úì Docker installed successfully${NC}"
else
    DOCKER_VERSION=$(docker --version | cut -d ' ' -f3 | cut -d ',' -f1)
    echo -e "${GREEN}‚úì Docker version: $DOCKER_VERSION${NC}"
fi

# 7. Check Docker Compose installation
echo -e "${BLUE}üîß Checking Docker Compose installation...${NC}"

# First check for standalone docker-compose (recommended for Ubuntu 24.04)
if [ -x "/usr/local/bin/docker-compose" ]; then
    DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose"
    DOCKER_COMPOSE_VERSION=$($DOCKER_COMPOSE_CMD --version | cut -d ' ' -f3 | cut -d ',' -f1)
    echo -e "${GREEN}‚úì Docker Compose standalone version: $DOCKER_COMPOSE_VERSION${NC}"
# Then check for system-installed docker-compose
elif command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD="docker-compose"
    DOCKER_COMPOSE_VERSION=$(docker-compose --version | cut -d ' ' -f3 | cut -d ',' -f1)
    echo -e "${GREEN}‚úì Docker Compose version: $DOCKER_COMPOSE_VERSION${NC}"
# Then check for Docker Compose plugin
elif docker compose version >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD="docker compose"
    DOCKER_COMPOSE_VERSION=$(docker compose version --short)
    echo -e "${GREEN}‚úì Docker Compose plugin version: $DOCKER_COMPOSE_VERSION${NC}"
# If none found, install standalone Docker Compose
else
    echo -e "${YELLOW}! Docker Compose not found. Installing Docker Compose...${NC}"
    curl -L "https://github.com/docker/compose/releases/download/v2.24.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose
    DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose"
    DOCKER_COMPOSE_VERSION=$($DOCKER_COMPOSE_CMD --version | cut -d ' ' -f3 | cut -d ',' -f1 || echo "Unknown")
    echo -e "${GREEN}‚úì Docker Compose installed version: $DOCKER_COMPOSE_VERSION${NC}"
fi

# 8. Auto-generate environment variable documentation file
echo -e "${BLUE}üîß Generating environment variable documentation...${NC}"
cat > ENV_VARIABLES.md << EOF
# Environment Variables Documentation

This document describes all the environment variables used in the Local AI Stack.

> **Note:** This project is based on work from [coleam00/local-ai-packaged](https://github.com/coleam00/local-ai-packaged) and [Digitl-Alchemyst/Automation-Stack](https://github.com/Digitl-Alchemyst/Automation-Stack) with customizations and improvements.

## Core Configuration

### Domain and URL Settings

| Variable | Description | Default |
|----------|-------------|---------|
| \`DOMAIN_NAME\` | Main domain for all services | \`kwintes.cloud\` |
| \`SUBDOMAIN\` | Subdomain for n8n service | \`n8n\` |
| \`N8N_HOSTNAME\` | Full hostname for n8n | \`n8n.kwintes.cloud\` |
| \`WEBUI_HOSTNAME\` | Full hostname for Web UI | \`openwebui.kwintes.cloud\` |
| \`FLOWISE_HOSTNAME\` | Full hostname for Flowise | \`flowise.kwintes.cloud\` |
| \`SUPABASE_HOSTNAME\` | Full hostname for Supabase | \`supabase.kwintes.cloud\` |
| \`OLLAMA_HOSTNAME\` | Full hostname for Ollama | \`ollama.kwintes.cloud\` |
| \`SEARXNG_HOSTNAME\` | Full hostname for SearXNG | \`searxng.kwintes.cloud\` |
| \`LETSENCRYPT_EMAIL\` | Email for Let's Encrypt certificates | \`tddezeeuw@gmail.com\` |

### n8n Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| \`N8N_ENCRYPTION_KEY\` | Encryption key for n8n (required) | Generated random string |
| \`N8N_USER_MANAGEMENT_JWT_SECRET\` | JWT secret for n8n user management | Generated random string |
| \`N8N_HOST\` | Hostname for n8n | \`n8n.kwintes.cloud\` |
| \`N8N_PROTOCOL\` | Protocol for n8n (http/https) | \`https\` |
| \`N8N_PORT\` | Port for n8n | \`5678\` (using port 5678 to avoid conflict with Supabase) |
| \`N8N_EDITOR_BASE_URL\` | Base URL for n8n editor | \`https://n8n.kwintes.cloud\` |
| \`WEBHOOK_URL\` | URL for external webhooks to reach n8n | \`https://n8n.kwintes.cloud/\` |
| \`GENERIC_TIMEZONE\` | Timezone for n8n workflows | \`Europe/Amsterdam\` |
| \`NODE_FUNCTION_ALLOW_EXTERNAL\` | Domains/IPs n8n can connect to | \`*\` (all) |

### System Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| \`TZ\` | Timezone | \`Europe/Amsterdam\` |
| \`LANG\` | Language locale | \`en_US.UTF-8\` |
| \`LC_ALL\` | Locale setting | \`en_US.UTF-8\` |

## Port Configuration

To ensure consistency and avoid port conflicts, we've configured each service to use the same port number internally and externally:

| Service | Port | Notes |
|---------|------|-------|
| n8n | 5678 | Using port 5678 to avoid conflict with Supabase |
| Supabase API | 8000 | Kong API Gateway |
| Flowise | 3001 | |
| OpenWebUI | 8080 | |
| Grafana | 3000 | |
| Prometheus | 9090 | |
| Qdrant | 6333 | |
| Ollama | 11434 | |
| SearXNG | 8080 | |
| Caddy | 80/443 | Reverse proxy for all services |

EOF
echo -e "${GREEN}‚úì Generated ENV_VARIABLES.md${NC}"

# 9. Check or create update script
echo -e "${BLUE}üîß Creating update script...${NC}"
cat > update_stack.sh << 'EOF'
#!/bin/bash
# Quick update script for Local AI Stack

set -e # Exit on error

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${BLUE}üîÑ Updating Local AI Stack...${NC}"

# Check for Docker Compose
if [ -x "/usr/local/bin/docker-compose" ]; then
    DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose"
elif command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD="docker-compose"
elif docker compose version >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD="docker compose"
else
    echo -e "${RED}‚ùå Docker Compose not found. Please install Docker Compose first.${NC}"
    exit 1
fi

# Pull latest images
echo -e "${BLUE}üì• Pulling latest Docker images...${NC}"
$DOCKER_COMPOSE_CMD pull
echo -e "${GREEN}‚úì Latest images pulled${NC}"

# Stop services
echo -e "${BLUE}üõë Stopping services...${NC}"
$DOCKER_COMPOSE_CMD down
echo -e "${GREEN}‚úì Services stopped${NC}"

# Apply configuration fixes
echo -e "${BLUE}üîß Applying configuration fixes...${NC}"
./fix_config.sh
echo -e "${GREEN}‚úì Configuration fixed${NC}"

# Start services
echo -e "${BLUE}üöÄ Starting services...${NC}"
$DOCKER_COMPOSE_CMD up -d
echo -e "${GREEN}‚úì Services started${NC}"

# Display service status
echo -e "${BLUE}üìä Service status:${NC}"
$DOCKER_COMPOSE_CMD ps

echo -e "${GREEN}‚úÖ Update completed successfully!${NC}"
EOF
chmod +x update_stack.sh
echo -e "${GREEN}‚úì Created update_stack.sh${NC}"

# 10. Create backup script
echo -e "${BLUE}üîß Creating backup script...${NC}"
cat > backup_stack.sh << 'EOF'
#!/bin/bash
# Backup script for Local AI Stack data

set -e # Exit on error

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

BACKUP_DIR="./backups"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
BACKUP_FILE="$BACKUP_DIR/local-ai-stack-backup-$TIMESTAMP.tar.gz"

echo -e "${BLUE}üì¶ Backing up Local AI Stack data...${NC}"

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Check for Docker Compose
if [ -x "/usr/local/bin/docker-compose" ]; then
    DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose"
elif command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD="docker-compose"
elif docker compose version >/dev/null 2>&1; then
    DOCKER_COMPOSE_CMD="docker compose"
else
    echo -e "${RED}‚ùå Docker Compose not found. Please install Docker Compose first.${NC}"
    exit 1
fi

# Get volume names
echo -e "${BLUE}üîç Identifying volumes to backup...${NC}"
VOLUMES=$($DOCKER_COMPOSE_CMD config --volumes | sort | uniq)
echo -e "${GREEN}‚úì Found volumes: $VOLUMES${NC}"

# Backup critical files
echo -e "${BLUE}üìã Backing up configuration files...${NC}"
mkdir -p "$BACKUP_DIR/config"
cp -f .env "$BACKUP_DIR/config/" 2>/dev/null || echo -e "${YELLOW}! .env not found${NC}"
cp -f Caddyfile "$BACKUP_DIR/config/" 2>/dev/null || echo -e "${YELLOW}! Caddyfile not found${NC}"
cp -f docker-compose.yml "$BACKUP_DIR/config/" 2>/dev/null || echo -e "${YELLOW}! docker-compose.yml not found${NC}"
cp -f prometheus.yml "$BACKUP_DIR/config/" 2>/dev/null || echo -e "${YELLOW}! prometheus.yml not found${NC}"
cp -f secrets.txt "$BACKUP_DIR/config/" 2>/dev/null || echo -e "${YELLOW}! secrets.txt not found${NC}"

# Export volumes
echo -e "${BLUE}üíæ Backing up Docker volumes...${NC}"
for volume in $VOLUMES; do
    echo -e "${BLUE}  Backing up $volume...${NC}"
    # Create a temporary container that mounts the volume and archive its contents
    docker run --rm -v $volume:/source -v $(pwd)/$BACKUP_DIR:/backup alpine sh -c "tar czf /backup/$volume.tar.gz -C /source ."
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}  ‚úì Backed up $volume${NC}"
    else
        echo -e "${RED}  ‚ùå Failed to back up $volume${NC}"
    fi
done

# Create final archive
echo -e "${BLUE}üì¶ Creating final backup archive...${NC}"
tar czf "$BACKUP_FILE" -C "$BACKUP_DIR" config $(for volume in $VOLUMES; do echo "$volume.tar.gz"; done)

# Clean up intermediate files
echo -e "${BLUE}üßπ Cleaning up temporary files...${NC}"
rm -f "$BACKUP_DIR"/*.tar.gz
rm -rf "$BACKUP_DIR/config"

echo -e "${GREEN}‚úÖ Backup completed successfully!${NC}"
echo -e "${GREEN}üìÅ Backup saved to: $BACKUP_FILE${NC}"
EOF
chmod +x backup_stack.sh
echo -e "${GREEN}‚úì Created backup_stack.sh${NC}"

# 11. Restart services if Docker is running
echo -e "${BLUE}üîß Checking Docker status...${NC}"
if systemctl is-active --quiet docker; then
    echo -e "${GREEN}‚úì Docker is running. Restarting services...${NC}"
    if [ "$DOCKER_COMPOSE_CMD" = "/usr/local/bin/docker-compose" ]; then
        echo -e "${BLUE}üöÄ Using standalone Docker Compose: $DOCKER_COMPOSE_CMD${NC}"
        $DOCKER_COMPOSE_CMD down
        $DOCKER_COMPOSE_CMD up -d
    elif [ "$DOCKER_COMPOSE_CMD" = "docker-compose" ]; then
        echo -e "${BLUE}üöÄ Using system Docker Compose: $DOCKER_COMPOSE_CMD${NC}"
        docker-compose down
        docker-compose up -d
    else
        echo -e "${BLUE}üöÄ Using Docker Compose plugin${NC}"
        docker compose down
        docker compose up -d
    fi
    echo -e "${GREEN}‚úì Services restarted${NC}"
else
    echo -e "${YELLOW}! Docker is not running. Please start Docker first with: sudo systemctl start docker${NC}"
fi

# Get server's public IP
SERVER_IP=$(hostname -I | awk '{print $1}')

echo -e "${GREEN}‚úÖ Configuration fixes completed successfully!${NC}"
echo ""
echo -e "${BLUE}üåê Services are now accessible at:${NC}"
echo -e "${GREEN}‚Ä¢ n8n:${NC} https://n8n.${DOMAIN_NAME} or http://${SERVER_IP}:5678"
echo -e "${GREEN}‚Ä¢ OpenWebUI:${NC} https://openwebui.${DOMAIN_NAME} or http://${SERVER_IP}:8080"
echo -e "${GREEN}‚Ä¢ Flowise:${NC} https://flowise.${DOMAIN_NAME} or http://${SERVER_IP}:3001"
echo -e "${GREEN}‚Ä¢ Grafana:${NC} https://grafana.${DOMAIN_NAME} or http://${SERVER_IP}:3000"
echo -e "${GREEN}‚Ä¢ Supabase Studio:${NC} https://studio.${DOMAIN_NAME} or http://${SERVER_IP}:54321"
echo -e "${GREEN}‚Ä¢ Qdrant:${NC} https://qdrant.${DOMAIN_NAME} or http://${SERVER_IP}:6333"
echo -e "${GREEN}‚Ä¢ Prometheus:${NC} https://prometheus.${DOMAIN_NAME} or http://${SERVER_IP}:9090"
echo -e "${GREEN}‚Ä¢ Ollama:${NC} https://ollama.${DOMAIN_NAME} or http://${SERVER_IP}:11434"
echo -e "${GREEN}‚Ä¢ SearXNG:${NC} https://searxng.${DOMAIN_NAME} or http://${SERVER_IP}:8080"
echo ""
echo -e "${BLUE}üìã Management commands:${NC}"
echo -e "${GREEN}‚Ä¢ Update stack:${NC} ./update_stack.sh"
echo -e "${GREEN}‚Ä¢ Backup data:${NC} ./backup_stack.sh"
echo -e "${GREEN}‚Ä¢ Fix configuration:${NC} ./fix_config.sh"
echo -e "${GREEN}‚Ä¢ Check service logs:${NC} docker logs [service_name]"
echo ""
echo -e "${YELLOW}! NOTE: The root domain (${DOMAIN_NAME}) redirects to n8n (https://n8n.${DOMAIN_NAME})${NC}" 